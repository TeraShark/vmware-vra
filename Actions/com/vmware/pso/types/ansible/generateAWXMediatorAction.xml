<?xml version='1.0' encoding='UTF-8'?>
<dunes-script-module name="generateAWXMediatorAction" result-type="Any" api-version="6.0.0" id="09e2a78f-7883-41d9-80f6-50c46e394dc9" version="0.5.1" category-name="com.vmware.pso.types.ansible">
  <param n="token" t="string"><![CDATA[]]></param>
  <param n="vROServer" t="Any"><![CDATA[]]></param>
  <param n="typeJSON" t="Any"><![CDATA[]]></param>
  <param n="namespace" t="string"><![CDATA[]]></param>
  <script encoded="false"><![CDATA[
var RestHostFactory = System.getModule("com.vmware.pscoe.library.rest").RestHostFactory();
var RestClient = System.getModule("com.vmware.pscoe.library.rest").RestClient();

var endpointUrl = vROServer.FQDN;
var endpointName = "vRO";
var requestContent = {};
requestContent.username = vROServer.adminUserName;
requestContent.password = vROServer.adminPassword;

var returnObjs = [];
var finderEventNames = [/*"findAll", "findById", "hasChildren",*/ "findRelations"];
var returnsMultiple = ["findRelations", "findAll"];

var actionObjects = [];

iterateTemplates(typeJSON);


function iterateTemplates(type) {

    if (type.isBaseType == null || type.isBaseType == false) {
        //first the base Type itself:
        generateActionContent(type);
        //Now the container for the base Type, if it exists (which is always should)
        if (type.containerName != null && type.containerName.length > 0) {
            var t = type;
            t.childType = type.typeName;
            t.isContainer = true;
            t.typeName = type.containerName;
            generateActionContent(t);
        }
    }
}

actionObjects.forEach(function(actionObject){
    var wfRef = JSON.parse(saveAction(actionObject.actionContent));
    var actionName = wfRef.fqn;
    returnObjs.push({ "actionName": actionName, "reference": { "event": actionObject.eventName, "typeName": actionObject.typeName } });
});


System.debug("Done...");

return returnObjs;


function generateActionContent(typeObject) {

    typeObject.AWXJobTemplates.forEach(function (template) {
        if (finderEventNames.indexOf(template.event) >= 0) {
            
            System.debug("Generating \"" + template.event + "\" Action for Type: " + typeObject.typeName);

            createConfigs(template, typeObject);

            var refObj = {};
            refObj.inputs = [];
            refObj.outputType = "";
            refObj.contentScript = "";

            setInAndOut(refObj, template, typeObject);

            var wfContent = {
                "output-type": refObj.outputType,
                "name": template.event + "_" + typeObject.typeName,
                "module": namespace,
                "version": "0.0.1",
                "fqn": namespace + "/" + template.event + "_" + typeObject.typeName,
                "script": refObj.contentScript,
                "bundleHasContent": false,
                "runtimeMemoryLimit": 0,
                "runtimeTimeout": 0,
                "input-parameters": refObj.inputs
            };

            var actionObject = { "eventName": template.event, "typeName": typeObject.typeName, "actionContent": wfContent };
            actionObjects.push(actionObject);
        }

    });
}

function createGuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

function setInAndOut(refObj, AWXJobTemplate, typeJSON) {
    switch (AWXJobTemplate.event) {
        case "findAll":
            refObj.inputs = [
                {
                    "description": "object type",
                    "name": "type",
                    "type": "string"
                }
            ];
            refObj.outputType = "Array/DynamicTypes:DynamicObject";
            break;
        case "findById":
            refObj.inputs = [
                {
                    "description": "object type",
                    "name": "type",
                    "type": "string"
                },
                {
                    "description": "object id",
                    "name": "id",
                    "type": "string"
                }
            ];
            refObj.outputType = "DynamicTypes:" + namespace + "." + typeJSON.typeName;
            break;
        case "hasChildren":
            refObj.inputs = [
                {
                    "description": "parent type",
                    "name": "parentType",
                    "type": "string"
                },
                {
                    "description": "parent id",
                    "name": "parentId",
                    "type": "string"
                },
                {
                    "description": "name of relation",
                    "name": "relationName",
                    "type": "string"
                }
            ];
            refObj.outputType = "boolean";
            refObj.contentScript = "return true;"
            break;
        case "findRelations":
            refObj.inputs = [
                {
                    "description": "parent type",
                    "name": "parentType",
                    "type": "string"
                },
                {
                    "description": "parent id",
                    "name": "parentId",
                    "type": "string"
                },
                {
                    "description": "name of relation",
                    "name": "relationName",
                    "type": "string"
                }
            ];
            refObj.outputType = "Array/DynamicTypes:DynamicObject";
            refObj.contentScript = generateFindRelationsScript(AWXJobTemplate);
            break;
    }
}

function generateFindRelationsScript(AWXJobTemplate) {
    //Base Container Type:
    var script = "\n//========================== vars =====================\nvar namespace = \"\";//get from type passed in\nvar id = parentId;\nvar parts = parentType.split(\".\");\nvar typeName = parts.pop();\nnamespace = parts.join(\".\");\n\n//what about findById and findAll? \n//We only get a type to work with, so how will we define the endPoint on these?\n//maybe force an endPoint input for these actions?\n//######### fetch configs #################\nSystem.debug(\"Fetching configs for [\" + namespace + \".\" + typeName + \"]...\");\nvar cat = Server.getConfigurationElementCategoryWithPath(namespace + \".\" + typeName);\nif (!cat) {\n    throw \"No Configurations found for \" + namespace + \".\" + typeName;\n}\n\nvar responseContent = \"\";\nvar endpointName = \"\";//Glean from Id below\nvar successful = false;\nvar uniqueId = \"\";\nvar jobId = \"\";\n\nvar typeProperties = [\"Name\", \"metadata\"];//from config\nvar outputMapping = \'[]\';//from config\nvar extra_vars = \'[{\"name\":\"cg_id\",\"inputReference\":\"parentId\"}]\';//from config\nvar templateId = \"11\";//from config\nvar childTypes = [];\nvar result = [];\n\n\nvar found = false;\n\nSystem.debug(\"Fetching Settings from configs...\")\ntry {\n    cat.configurationElements.forEach(function (elem) {\n        System.debug(elem.name);\n        if (!found) {\n            if (elem.name == \"{{eventName}}\") {\n                childTypes = JSON.parse(elem.getAttributeWithKey(\"childTypes\").value);\n                found = true;\n            }\n        }\n    });\n} catch (e) {\n    throw \"Missing Configuration values for events for Type: \" + typeName;\n}\nif (!found) {\n    throw \"Missing Configuration values for events for Type: \" + typeName;\n\n}\n\nchildTypes.forEach(function (typeName) {\n\n    System.debug(\"Fetching child configs for [\" + namespace + \".\" + typeName + \"]...\");\n    var cat = Server.getConfigurationElementCategoryWithPath(namespace + \".\" + typeName);\n    if (!cat) {\n        throw \"No child Configurations found for \" + namespace + \".\" + typeName;\n    }\n    found = false;\n    try {\n        cat.configurationElements.forEach(function (elem) {\n            //System.debug(elem.name);\n            if (!found) {\n                if (elem.name == \"{{eventName}}\") {\n                    typeProperties = JSON.parse(elem.getAttributeWithKey(\"typeProperties\").value);\n                    outputMapping = elem.getAttributeWithKey(\"outputMapping\").value;\n                    extra_vars = elem.getAttributeWithKey(\"extra_vars\").value;\n                    templateId = elem.getAttributeWithKey(\"templateId\").value;\n                    found = true;\n                }\n            }\n        });\n    } catch (e) {\n        throw \"Missing Configuration values for events for Type: \" + typeName;\n    }\n    if (!found) {\n        throw \"Missing Configuration values for events for Type: \" + typeName;\n\n    }\n\n\n    //######### prepare context #################\n    var evars = { \"extra_vars\": {} };\n    evars.extra_vars.cg_id = parentId;\n    extra_vars = JSON.stringify(evars);\n    //Get Endpoint and ID from input\n    var split = id.split(\"|#|\");\n    if (split.length > 1) {\n        endpointName = split[1];\n    }\n    uniqueId = split[0];\n    System.debug(uniqueId);\n    System.debug(endpointName);\n\n    //######### launch job #################\n    jobId = System.getModule(\"com.vmware.pso.types.ansible\").launchAWXJob(endpointName, extra_vars, templateId, namespace, typeName);\n\n    //######### get job status  #################\n    successful = System.getModule(\"com.vmware.pso.types.ansible\").getAWXJobStatus(endpointName, jobId, namespace, typeName);\n\n    //######### get job output  #################\n    responseContent = System.getModule(\"com.vmware.pso.types.ansible\").getAWXJobOutput(endpointName, jobId, namespace, typeName);\n\n    //######### parse \& assign  #################\n\n    var allResults = [];\n    var regexp = null;\n    var regexResult = null;\n    System.debug(\"Iterating Mappings and Parsing Ansible output...\");\n    System.debug(outputMapping);\n    var mapping = JSON.parse(outputMapping);\n\n    System.debug(responseContent);\n\n    mapping.forEach(function (map) {\n        System.debug(\"Mapping property: \" + map.typeReference);\n\n        regexp = new RegExp(map.regExp, map.regExpFlag);\n        System.debug(\"RegExp: \" + regexp.source + \" | Flags: \" + map.regExpFlag);\n\n        regexResult = [];\n        var ar;\n        while (ar = regexp.exec(responseContent)) {\n            //build an object by using the map name and the FIRST regex captured group:\n            var obj = {};\n            obj[map.typeReference] = ar.length > 0 ? ar[1] : null;\n            regexResult.push(obj);\n        };\n        allResults.push(regexResult);\n\n    });\n\n\n    var mappedResults = [];\n    var columnIndex = 0;\n\n    if (allResults.length > 0) {\n        allResults[0].forEach(function (results) {\n            var rowIndex = 0;\n            var newObj = {};\n            while (rowIndex < allResults.length \&\& columnIndex < allResults[rowIndex].length) {\n                var obj = allResults[rowIndex][columnIndex];\n                newObj[Object.keys(obj)[0]] = obj[Object.keys(obj)[0]];\n                rowIndex++;\n            }\n            columnIndex++;\n            mappedResults.push(newObj);\n        });\n    }\n\n    System.debug(JSON.stringify(mappedResults));\n\n    mappedResults.forEach(function (output) {\n        System.debug(\"Creating type for \" + namespace + \"|\" + typeName + \"|\" + JSON.stringify(typeProperties));\n        var obj = DynamicTypesManager.makeObject(namespace, typeName, \"1\", typeName, []);\n\n        for (var i = 0; i < Object.keys(output).length; i++) {\n            obj.setProperty(Object.keys(output)[i], output[Object.keys(output)[i]]);\n            if (Object.keys(output)[i].toLowerCase() == \"id\")\n                obj.id = output[Object.keys(output)[i]] + \"|#|\" + endpointName;\n            if (Object.keys(output)[i].toLowerCase() == \"name\")\n                obj.name = output[Object.keys(output)[i]];\n        }\n        System.debug(JSON.stringify(obj));\n        result.push(obj);\n    });\n\n});\n\n\nSystem.debug(JSON.stringify(result));\nreturn result;\n";
    script = script.replace(/{{eventName}}/g, AWXJobTemplate.event);
    script = script.replace("//|||||extravars_script|||||", generateExtraVarsScript(AWXJobTemplate));
    script = script.replace("//|||||parse_script|||||", generateParseScript(AWXJobTemplate.event));
    return script;
}

function saveAction(actionContent) {
    var request = {
        path: '/vco-controlcenter/client/api/platform/actions?uniqueName=true',
        params: [],
        content: actionContent,
        options: {
            skipEncodeParams: true,
            returnResponseObject: true,
            returnResponseObjectForReal: false,
            stringifyJsonContent: true,
            interpretResponseCode: false,
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'Authorization': 'Bearer ' + token
            },
            errorHandler: {					//Defines a retry mechanism in case of failed requests
                numberOfRetries: 3,			//Number of retries
                retryWaitInterval: 15,			//Polling interval in seconds
                errorsToRetry: ["Read timed out"]	//Specific errors to retry (Default: ["Connection pool shut down"])
            }
        }
    };
    System.debug("Creating new Action...");
    //var urlTemplate = "workflows/{id}";
    var restHost = RestHostFactory.newHostWithBasicAuth(endpointUrl, endpointName, requestContent.username, requestContent.password);
    var restClient = new RestClient(restHost);

    var httpData = restClient.post(request.path, request.params, request.content, request.options);
    if (httpData.statusCode != 201) {
        System.debug(JSON.stringify(request));
        throw "Error calling API. Received Status Code: " + httpData.statusCode;
    }
    System.debug(httpData.statusCode);
    return httpData.contentAsString;
}

function generateExtraVarsScript(AWXJobTemplate) {

    var extra_vars_script = 'var evars = {"extra_vars":{}};\r\n';

    AWXJobTemplate.extra_vars.forEach(function (e) {
        extra_vars_script += 'evars.extra_vars.' + e.name + ' = ' + e.inputReference + ';\r\n';
    });
    extra_vars_script += "extra_vars = JSON.stringify(evars);\n";
    if (AWXJobTemplate.event.toLowerCase() == "findrelations")
        extra_vars_script += "//Get Endpoint and ID from input\nvar split = id.split(\"|#|\");\nif (split.length > 1){\n  endpointName = split[1];\n}\nuniqueId = split[0];\nSystem.debug(uniqueId);\nSystem.debug(endpointName);";

    return extra_vars_script;
}

function generateParseScript(eventName) {
    var parseScript = "\nvar outputObj = DynamicTypesManager.makeObject(namespace, typeName, \"1\", typeName, typeProperties);\n\n\nvar regexp = null;\nvar result = \"\";\nSystem.debug(\"Iterating Mapping and Parsing Ansible output...\");\nvar mapping = JSON.parse(outputMapping);\nvar id = null;\nmapping.forEach(function(map){\n    System.debug(\"Mapping property: \" + map.typeReference);\n \n    regexp = new RegExp(map.regExp, map.regExpFlag);\n    System.debug(\"RegExp: \" + regexp.source + \" | Flags: \" + map.regExpFlag);\n\n    result = responseContent.match(regexp);\n    if (result \&\& result.length > 1){\n        System.debug(\"Found value: \" + result[1]);\n        System.debug(map.typeReference + \":\" + result[1]);\n        if(map.typeReference.toLowerCase() == \"id\")\n            id = result[1];\n        outputObj.setProperty(map.typeReference, result[1]);\n    }\n    else{\n        System.error(\"Expression returned no results\");\n    }\n});\n\nif(id != null)\n    outputObj.id = id + \"|#|\" + endpointName;\n    \nSystem.debug(\"object id: \" + outputObj.id);\n\nresult = outputObj;\n";

    if (returnsMultiple.indexOf(eventName) >= 0) {
        parseScript = "\nvar allResults = [];\nvar outputObjs = [];\nvar regexp = null;\nvar regexResult = null;\nSystem.debug(\"Iterating Mappings and Parsing Ansible output...\");\nvar mapping = JSON.parse(outputMapping);\nvar id = null;\n\nvar result = [];\n\nSystem.debug(responseContent);\n\nmapping.forEach(function (map) {\n    System.debug(\"Mapping property: \" + map.typeReference);\n\n    regexp = new RegExp(map.regExp, map.regExpFlag);\n    System.debug(\"RegExp: \" + regexp.source + \" | Flags: \" + map.regExpFlag);\n\n    regexResult = [];\n    var ar;\n    while (ar = regexp.exec(responseContent)) {\n        //build an object by using the map name and the FIRST regex captured group:\n        var obj = {};\n        obj[map.typeReference] = ar.length > 0 ? ar[1] : null;\n        regexResult.push(obj);\n    };\n    allResults.push(regexResult);\n\n});\n\n\nvar mappedResults = [];\nvar columnIndex = 0;\n\nif (allResults.length > 0) {\n    allResults[0].forEach(function (results) {\n        var rowIndex = 0;\n        var newObj = {};\n        while (rowIndex < allResults.length \&\& columnIndex < allResults[rowIndex].length) {\n            var obj = allResults[rowIndex][columnIndex];\n            newObj[Object.keys(obj)[0]] = obj[Object.keys(obj)[0]];\n            rowIndex++;\n        }\n        columnIndex++;\n        mappedResults.push(newObj);\n    });\n}\n\nSystem.debug(JSON.stringify(mappedResults));\n\nmappedResults.forEach(function (output) {\n    var obj = DynamicTypesManager.makeObject(namespace, typeName, \"1\", typeName, []);\n    if (obj != null) {\n        System.debug(\"Instantiated \" + typeName);\n        for (var i = 0; i < Object.keys(output).length; i++) {\n            obj.setProperty(Object.keys(output)[i], output[Object.keys(output)[i]]);\n            if (Object.keys(output)[i].toLowerCase() == \"id\")\n                obj.id = output[Object.keys(output)[i]] + \"|#|\" + endpointName;\n            if (Object.keys(output)[i].toLowerCase() == \"name\")\n                obj.name = output[Object.keys(output)[i]];\n        }\n        outputObjs.push(obj);\n    } else System.error(\"Instantiation of type [\" + namespace + \".\" + typeName + \"] returned null!\");\n});\n\nresult = outputObjs;\n";
    }

    return parseScript;
}


function createConfigs(AWXJobTemplate, typeJSON) {

    try{
       
        var elem = Server.createConfigurationElement(namespace + "." + typeJSON.typeName, AWXJobTemplate.event);
        elem.setAttributeWithKey("typeProperties", stringy(typeJSON.typeProperties));
        elem.setAttributeWithKey("outputMapping", stringy(AWXJobTemplate.outputMapping));
        elem.setAttributeWithKey("extra_vars", stringy(AWXJobTemplate.extra_vars));
        elem.setAttributeWithKey("templateId", AWXJobTemplate.templateId);
        if(typeJSON.isContainer == true){
            elem.setAttributeWithKey("childTypes", stringy(typeJSON.containerChildTypeNames));
        }
        else{
            elem.setAttributeWithKey("childTypes", stringy(typeJSON.allChildTypeNames));
        }
        

        System.debug("Created Configuration for " + typeJSON.typeName + ":" + AWXJobTemplate.event);
    }
    catch(e){
        System.error("Unable to create Configuration: " + e.message);
    }

}

function stringy(str){
    return JSON.stringify(str);
}]]></script>
</dunes-script-module>